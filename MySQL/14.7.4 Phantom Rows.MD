

# 14.7.4 Phantom Rows

==当同一事务内同一查询在不同的时间产生了不同的结果集时，就是发生了所谓的幻象问题==。例如，如果执行了两次 SELECT，但是第二次返回了第一次没有返回的行，那么该行就是一个幻像行。

 假设在 child 表的 id 列上有索引，你想读取并锁定表中 id 值大于 100 的所有行，并打算稍后更新所选行的某些列：

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

该查询从 id 大于 100 的第一条记录开始扫描索引。表中包含 id 值为 90 和 102 的行。如果只锁定被扫描过的索引记录，而不锁定间隙（在本例中为 90 到 102 之间的间隙），则另一个会话可以在表中插入一个 ID 为 101 的新行。如果在同一个事务中执行相同的 SELECT，则会在查询返回的结果集中看到一个 id 为101 的新行(幻象)。如果我们将行的集合视为数据项，那么新的幻象子集违反了事务的隔离性，在事务执行期间，已经读取的数据不应该发生变化。

为了防止幻象的产生，InnoDB 使用了==称为 next-key 锁的算法，它结合了索引行锁和间隙锁==。 InnoDB 执行行级锁的方式是：当它搜索或扫描表索引时，会在遇到的索引记录上加共享或互斥锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的 next-key 锁也会影响该索引记录之前的“间隙”。也就是说，next-key 锁是索引记录锁定加上索引记录之前的间隙上的间隙锁。如果一个会话已经在一个索引中的记录 R 上加了共享锁或排他锁，另一个会话不能在紧接在索引顺序中的 R 之前的间隙中插入新的索引记录。

当 InnoDB 扫描索引时，它也可以锁定索引中最后一条记录之后的间隙。就像前面的例子中发生的那样：为了防止在表中插入任何 ID 大于 100 的数据，InnoDB 也锁定了 102 之后的间隙。

您可以使用 next-key 锁在应用程序中实现唯一性检查：如果您以共享模式读取数据，但没有看到与要插入的行重复的记录，则可以安全地插入新行，并且知道在读取期间加到行的后继节点上的 next-key 锁可防止任何人同时插入重复行。因此，==next-key 锁使您可以锁定表中不存在的内容==。

如 [Section 14.7.1, “InnoDB Locking”](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)  中所述，可以禁用间隙锁。这可能会导致幻象问题，因为在禁用间隙锁时，其他会话可以在间隙中插入新行。