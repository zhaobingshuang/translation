#  14.7.3 Locks Set by Different SQL Statements in InnoDB

锁定读、UPDATE 或者 DELETE 通常会对处理 SQL 语句时==扫描到的每个索引记录添加记录锁==。==它不关心 WHERE 条件是否能排除某些行==。InnoDB 不记得确切的 WHERE 条件，只知道哪个索引范围被扫描了。这个锁通常是 next-key lock，它还会阻塞那些向记录前间隙中的插入。间隙锁能被显式的禁用，这将导致 next-key lock 失效。For more information, see [Section 14.7.1, “InnoDB Locking”](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)。事务隔离级别也会影响加锁的种类；see [Section 14.7.2.1, “Transaction Isolation Levels”](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)。

如果在搜索中==用到了二级索引==，且索引记录==被加了排它锁==，则 InnoDB 还将检索相应的聚集索引记录并锁定它们。如果==只是加了共享锁==，那有可能不会锁定相应的聚集索引，例如，发生了索引覆盖。

如果==没有适合你的语句的索引==，为了处理语句，MySQL 会扫描整个表，==表中的每一行都会被锁定==，进而会==阻塞其他用户对表的所有插入==。创建良好的索引时非常重要的，这样查询就不必扫描很多不必要的行。

InnoDB 加锁类型，如下所示：

- [`SELECT ... FROM`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 是一致性读，读取数据库的快照，且不会加锁，除非事务隔离级别被设置为 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)。对于 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)级别，搜索时会在遇到的索引记录上加共享的 next-key 锁。但是，==对于使用唯一索引来搜索唯一行的语句，只需要锁定索引记录（不会锁定间隙）==。

- 对于 [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 或 [`SELECT ... LOCK IN SHARE MODE`](https://dev.mysql.com/doc/refman/5.7/en/select.html)，会锁定被扫描过的行，预期会释放那些不符合条件的行锁（例如，它们不符合WHERE 子句中给出的条件）。然而，在有些情况，行可能不会被立即解锁，因为结果行与其原始源之间的关系在查询执行期间丢失了。例如，在 UNION 中，在评估它们是否符合结果集之前，可以将表中被扫描（和锁定）的行插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系将丢失，并且直到查询执行结束后，行才被解锁。

- [`SELECT ... LOCK IN SHARE MODE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 对在搜索时遇到的所有索引记录上加==共享的 next-key 锁==。但是，对于使用唯一索引来搜索唯一行的语句，只需要锁定索引记录（不会锁定间隙）。

- [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 对在搜索时遇到的每条记录上加==排他的 next-key 锁==。但是，对于使用唯一索引来搜索唯一行的语句，只需要锁定索引记录（不会锁定间隙）。

  对于在搜索时遇到的索引记录，[`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 会阻塞其他会话执行 [`SELECT ... LOCK IN SHARE MODE`](https://dev.mysql.com/doc/refman/5.7/en/select.html)，或者某些事务隔离级别的读取操作。一致读会忽略读视图（read view）中的任何锁。

- [`UPDATE ... WHERE ...`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 对在搜索时遇到的每条记录上加==排他的 next-key 锁==。但是，对于使用唯一索引来搜索唯一行的语句，只需要锁定索引记录（不会锁定间隙）。

- 当 UPDATE 修改聚集索引记录时，将会隐式的对受影响的二级索引记录加锁。在插入新的二级索引记录之前执行重复检查扫描时，以及在插入新的二级索引记录时，UPDATE 操作还会在受影响的二级索引记录上加==共享锁==。（只有在索引时==唯一索引==时，才会进行重复性检查，唯一索引从 A 更新到 B，会对索引记录 A、B 都加锁）。

- [`DELETE FROM ... WHERE ...`](https://dev.mysql.com/doc/refman/5.7/en/delete.html) 对在搜索时遇到的每条记录上加==排他的 next-key 锁==。但是，对于使用唯一索引来搜索唯一行的语句，只需要锁定索引记录（不会锁定间隙）。

- [`INSERT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html) 会在被插入的记录上加==排它锁==。==只是一个索引记录锁，不是一个 next-key 锁（没有间隙锁）==，且不会阻止向被插入行之前的间隙中插入数据。

  在执行插入操作之前，会加一种称之为==插入意向锁的间隙锁==。==当多个事务向同一个索引间隙中插入时，只要它们不是往同一个位置插入，那么就不需要相互等待==。假设有索引值 4 和 7，有不同事务尝试插入 5 和 6，在获取被插入的记录上==排它锁==之前，它们都会使用插入意向锁锁定 4 到 7 之间的间隙，但它们不会相互阻塞，因为行是不冲突的。

  如果发生了 ==duplicate-key 错误==，会在==重复的索引记录上加共享锁==。共享锁的使用可能导致==死锁==，比如以下情况，一个会话已经持有索引记录的排它锁，此时又有多个会话尝试插入相同的记录，随后第一个会话释放了行的排它锁。假设 InnoDB 表 t1 的结构如下：

  ```sql
  CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
  ```

  假设三个会话按顺序执行以下操作：

  Session 1：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  Session 2：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  Session 3：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  Session 1：

  ```sql
  ROLLBACK;
  ```

  Session 1 的操作获取了行的排他锁。Session 2 和 3 的操作都会发生 duplicate-key 错误，且它们都会请求该行的共享锁（但是都被阻塞了）。Session 1 回滚时，释放了行的排它锁，且 Session 2 和 3 将同时获取到该行的共享锁。此时，Session 2 和 3 发生了死锁：由于另一个会话持有了行的共享锁，所以两个会话都无法获取行的排它锁。

  如果表中已经有一个索引值为 1 的行，那么三个会话依次执行以下操作，也会出现类似的情况：

  Session 1：

  ```sql
  START TRANSACTION;
  DELETE FROM t1 WHERE i = 1;
  ```

  Session 2：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  Session 3：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  Session 1：

  ```sql
  COMMIT;
  ```

  Session 1 的操作获取了行的排他锁。Session 2 和 3 的操作都会发生 duplicate-key 错误，且它们都会请求该行的共享锁（但是都被阻塞了）。Session 1 提交时，释放了行的排它锁，且 Session 2 和 3 将同时获取到该行的共享锁。此时，Session 2 和 3 发生了死锁：由于另一个会话持有了行的共享锁，所以两个会话都无法获取行的排它锁。

- [`INSERT ... ON DUPLICATE KEY UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html) 与简单的 INSERT 不同之处在于当发生 ==duplicate-key 错误==时，在被更新的行上==加的是排它锁==而非共享锁。对于主键，加的是索引记录锁（不锁定之前的间隙）；对于唯一索引，加的是 next-key 锁。

- 如果唯一键上没有冲突，则 [`REPLACE`](https://dev.mysql.com/doc/refman/5.7/en/replace.html)  就像 INSERT 一样完成。否则，在要替换的行上加排他的 next-key 锁。

- INSERT INTO T SELECT ... FROM S WHERE ... 在插入到表 T 的每一行上加排他的索引记录锁（不锁定间隙）。如果事务隔离级别是 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed) 或启用了 [`innodb_locks_unsafe_for_binlog`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog) 且事务隔离级别不是 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)，InnoDB 在表 S 上执行一致性非锁定读。否则，会对表 S 中的行加共享的 next-key 锁。在后一种情况下，InnoDB 必须加锁：在使用基于语句的二进制日志进行前滚恢复期间，必须以与以前完全相同的方式执行每个SQL语句。

  [`CREATE TABLE ... SELECT ...`](https://dev.mysql.com/doc/refman/5.7/en/create-table.html) 与 [`INSERT ... SELECT`](https://dev.mysql.com/doc/refman/5.7/en/insert-select.html) 一样。

  当 SELECT 被用于 `REPLACE INTO t SELECT ... FROM s WHERE ... ` 或  `UPDATE t ... WHERE col IN (SELECT ... FROM s ...)`时，InnoDB 将对表 s 的行加共享的 next-key 锁。

- ==TODE==

- 如果在表上定义了 FOREIGN KEY 约束，则对于任何需要检查约束条件的插入、更新或删除操作，都会为了检查约束条件而在记录上加共享的行锁。在约束失败的情况下，InnoDB 也会加这些锁。

- [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) 会加表锁，但是这些锁是在 InnoDB 之上的 MySQL 层加的。如果 innodb_table_locks = 1（默认值）且 [`autocommit = 0`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit) ，InnoDB 能知道表锁的存在，且 MySQL 层也能知道行锁的存在。

  否则，InnoDB 的自动死锁检测将无法检测到涉及到表锁的死锁。另外，由于这种情况下 MySQ L层不知道行级锁的存在，所以在某会话拥有表的行锁的情况下，其他会话依旧可以获取到表锁。但是，这不会危及事务完整性，如 [Section 14.7.5.2, “Deadlock Detection”](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html) 中所述。

- 如果 innodb_table_locks = 1（默认值），则 [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) 在每个表上获取两个锁。除了 MySQL 层上的表锁外，它还获得一个 InnoDB 表锁。4.1.2 版本之前的 MySQL 没有获取 InnoDB 表锁；可以通过设置 innodb_table_locks = 0 来选择旧的行为。如果没有获取 InnoDB 表锁，即使表的某些记录被其他事务锁定，LOCK TABLES 也会完成。 

  在 MySQL 5.7 中，innodb_table_locks = 0 对于用 `LOCK TABLES ... WRITE` 显式锁定的表无效。对于隐式的 LOCK TABLES ... WRITE （例如，触发器）或 LOCK TABLES ... READ 锁定的表进行读取或写入，它确实具有作用。

- 当事务提交或终止时，事务持有的所有 InnoDB 锁都将被释放。因此，在 autocommit=1 模式下在 InnoDB 表上调用 [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html)没有多大意义，因为获得的 InnoDB 表锁会立即释放。

- 不能在事务中间锁定其他表，因为 [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) 执行隐式的  [`COMMIT`](https://dev.mysql.com/doc/refman/5.7/en/commit.html) 和 [`UNLOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html)。