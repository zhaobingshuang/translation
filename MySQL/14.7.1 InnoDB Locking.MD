[toc]

# 14.7.1 InnoDB Locking

本章介绍了 InnoDB 锁的种类
- 共享锁、排它锁（Shared and Exclusive Locks）
- 意向锁（Intention Locks）
- 记录锁（Record Locks）
- 间隙锁（Gap Locks）
- Next-Key 锁
- 插入意向锁（Insert Intention Locks）
- 自增锁（AUTO-INC Locks）
- 空间索引的谓词锁（Predicate Locks for Spatial Indexes）


## 共享锁、排它锁（Shared and Exclusive Locks）
InnoDB 实现了标准的行级锁，分为两种：共享锁（S）、排它锁（X）。
- 共享锁（S）允许持有锁的事务读取一行
- 排它锁（X）允许持有锁的事务更新或删除一行

如果事务 T1 持有行 r 的共享锁（X），事务 T2 对行 r 的任何类型的锁请求都不能被立即授予。取而代之的是，事务 T2 必须等待事务 T1 去释放行 r 上的锁。
##  意向锁（Intention Locks）
InnoDB 支持多粒度锁定，允许行锁和表锁共存。例如，`LOCK TABLES ... WRITE`将获取表的排它锁（X）。为了实现多粒度的锁定，InnoDB 使用了意向锁。==意向锁是表级别的锁==，它表明稍后事务要对表中的行获取哪种类型的锁（共享、排他）。有两种意向锁：
- 意向共享锁（IS）表示事务打算在表中的行上加共享锁。
- 意向排它锁（IX）表示事务打算在表中的行上加排他锁。
例如，`SELECT ... LOCK IN SHARE MODE`会加 IS，`SELECT ... FOR UPDATE`会加 IX。
意向锁的协议如下：
- 事务在获取表中某行的共享锁之前，必须先表的 IS 锁或更重量级的锁。
- 事务在获取表中某行的排他锁之前，必须先表的 IX 锁。

表级别锁的兼容性如下表

|      | X    | IX   | S    | IS   |
| ---- | ---- | ---- | ---- | ---- |
| X    | 冲突 | 冲突 | 冲突 | 冲突 |
| IX   | 冲突 | 兼容 | 冲突 | 兼容 |
| S    | 冲突 | 冲突 | 兼容 | 兼容 |
| IS   | 冲突 | 兼容 | 兼容 | 兼容 |
==意向锁之间是完全兼容的。==

如果锁与现有的锁是兼容的，则将其授予请求的事务，若与现有的锁是冲突的，则不会授予锁。事务将等待直到冲突的现有锁被释放。如果锁请求与现有的锁冲突，且由于会导致死锁而不能被授予锁，就会发生错误。

==意向锁不会阻塞除全表请求（比如LOCK TABLES ... WRITE）之外的其他请求==。意向锁的主要目的就是表明有人正在锁定或将要锁定表中的某行。

在`SHOW ENGINE INNODB STATUS`和 InnoDB monitor 的输出中，意向锁的事务信息如下：

```sql
TABLE LOCK table `test`.`t` trx id 10080 lock mode IX
```

## 记录锁（Record Locks）
==记录锁是索引上的锁==。例如，`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`；防止其他事务插入、修改、删除 t.c1 = 10 的行。

记录锁总是会锁定索引记录，即使一张表没有任何索引。在这种情况下，InnoDB 会创建一个隐藏的聚集索引，并使用这个索引来锁定记录。See [Section 14.6.2.1, “Clustered and Secondary Indexes”](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html).

在`SHOW ENGINE INNODB STATUS`和 InnoDB monitor 的输出中，记录锁的事务信息如下：

```sql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10078 lock_mode X locks rec but not gap
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```



## 间隙锁（Gap Locks）

间隙锁是一种索引记录之间的间隔上的锁，或第一个索引之前、最后一个索引之后的间隔上的锁。例如，` SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`；防止其他事务向 t.c1 列中插入15，不管该列中是否已经有这样的值了，因为这个范围内所有现有值之间的间隙都被锁定了。

间隙可能跨越单个索引值，多个索引值，甚至是空的。

间隙锁是性能与并发的之间权衡的一部分，有些事务隔离级别使用，而有些不使用。

==对于使用唯一索引去查询一个唯一的行这样的语句，是不需要间隙锁的==。（这不包括查询条件只包含联合唯一索引的某些列的这种情况；这种情况下会有间隙锁。）例如，id 列有一唯一索引，下面的语句只会在 id 的值为 100 的行上有一个索引记录锁，并且不会阻止其他会话在之前的间隙插入数据：

```sql
SELECT * FROM child WHERE id = 100;
```

如果 id 列没有索引或者只有非唯一的索引，上面的语句会锁定前面的间隙。

还值得注意的是，==不同的事务可以在同一个间隙上持有冲突的锁==。例如，事务 A 持有某个间隙的共享间隙锁（gap S-lock）的同时，事务 B 可以持有同一个间隙的排他间隙锁（gap X-lock）。允许冲突间隙锁的原因是，如果索引中的记录被删除，则必须合并由不同事务持有的记录上的间隙锁。？？？

InnoDB 中的间隙锁是“纯抑制性”，这意味着它的==唯一目的就是防止其他事务向间隙中插入数据==。间隙锁可以共存。==被一个事务持有的间隙锁不会阻止另一个事务获得同一个间隙的间隙锁==。==共享和排他间隙锁没有任何区别==。它们之间互==不冲突==，并且执行相同的功能。

间隙锁能被显式的禁用。比如将事务隔离级别改为 ==READ COMMITTED==，或者启用系统变量 ==innodb_locks_unsafe_for_binlog（已被弃用）==。在这种情况下，对于查询和索引扫描来说，间隙锁是禁用，仅用于外键约束检查和重复键检查。

将事务隔离级别改为==READ COMMITTED==，或者启用系统变量==innodb_locks_unsafe_for_binlog==还有其他的影响。MySQL 测试完 where 条件后，==会释放不满足条件的记录锁==。对 Update 语句来说，InnoDB 使用==半一致性读==，将返回最新的版本给 MySQL，以便 MySQL 确定该行是否与 UPDATE 的 WHERE 条件匹配。

## Next-Key

==next-key 是记录锁与索引记录前的间隙锁的组合==。

InnoDB 执行行级锁的方式：当搜索或扫描一个表的索引时，会对==遇到的索引记录==加共享或排它锁。因此，行级锁实际上是索引记录锁。索引记录上的 next-key 也会影响索引记录之前的间隙。也就是说，next-key 锁是索引记录锁加上索引记录之前的间隙锁。如果一个会话在一个索引中的记录 R 上有一个共享锁或排他锁，另一个会话不能在 R 之前的间隙中插入新的索引记录。

假设一个索引包含值10、11、13 和 20。该索引可能的 next-key 锁包括以下区间，圆括号表示排除区间端点，方括号表示包含端点

```
(negative infinity, 10]
(10, 11]
(11, 13]
(13, 20]
(20, positive infinity)
```

对于最后一个区间，next-key 锁锁定了索引中最大值之后的间隔和未记录"supremum"，supremum 大于索引中所有的实际值，且不是一个真正的索引记录。所以，实际上 next-key 锁只锁定了最大索引值后面的间隔。

默认情况下，InnoDB 事务隔离级别为 REPEATABLE READ。InnoDB 使用  next-key 锁进行搜索和索引扫描，这能防止幻读 (see [Section 14.7.4, “Phantom Rows”](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html))。

==InnoDB 锁的基本单位为 next-key 锁==。

在`SHOW ENGINE INNODB STATUS`和 InnoDB monitor 的输出中，next-key 锁的事务信息如下：

```sql
RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`
trx id 10080 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 8000000a; asc     ;;
 1: len 6; hex 00000000274f; asc     'O;;
 2: len 7; hex b60000019d0110; asc        ;;
```



## 插入意向锁（Insert Intention Locks）

插入意向锁是一种用于 INSERT 操作的==间隙锁==，是在新的行插入之前设置的。这个锁表明，==多个事务向同一个间隙插入时，只要不是插入到间隙中的同一个位置就不需要相互等待==。假设索引中已有值 4 和 7。不同的事务分别尝试插入值 5 和 6，在获取被插入行的排它锁之前，两事务都会使用插入意向锁锁定 4 到 7 之间的间隙，但他们不会相互阻塞，因为行是不冲突的。

==插入意向锁是相互兼容的==。

下面的实例演示了在获取被插入行的排它锁之前，都会使用插入意向锁的情。例子涉及两个客户端 A 和 B。

客户端 A 创建了包含两个索引记录（90 和 102）的表，然后开始了一个事务，对 ID 大于 100 的索引记录加了排它锁，这个排它锁包含 102 之前的间隙：

```sql
mysql> CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id)) ENGINE=InnoDB;
mysql> INSERT INTO child (id) values (90),(102);

mysql> START TRANSACTION;
mysql> SELECT * FROM child WHERE id > 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
```

客户端 B 开始事务并向间隙中插入记录。在等待获取排他锁时，事务持有一个插入意向锁。

```sql
mysql> START TRANSACTION;
mysql> INSERT INTO child (id) VALUES (101);
```

在`SHOW ENGINE INNODB STATUS`和 InnoDB monitor 的输出中，插入意向锁的事务信息如下：

```sql
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; asc    f;;
 1: len 6; hex 000000002215; asc     " ;;
 2: len 7; hex 9000000172011c; asc     r  ;;...
```

## 自增锁（AUTO-INC Locks）

自增锁是一种特殊的表锁，被插入自增列的事务持有。最简单的情况，如果一个事务正在向表中插入值，那么任何其他事务都必须等待自己对该表的插入，以便第一个事务在插入时能有连续的主键值。

==innodb_autoinc_lock_mode== 配置项能控制用于自增锁定的算法。它使你可以选择如何在可预测的自动增量值序列与插入操作的最大并发性之间进行权衡。

For more information, see [Section 14.6.1.6, “AUTO_INCREMENT Handling in InnoDB”](https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html).

## 空间索引的谓词锁（Predicate Locks for Spatial Indexes）

