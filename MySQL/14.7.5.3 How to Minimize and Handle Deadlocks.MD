#### 14.7.5.3 How to Minimize and Handle Deadlocks

本节以 [Section 14.7.5.2, “Deadlock Detection”](https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlock-detection.html) 中有关死锁的概念性信息为基础。它说明了如何组织数据库操作以最大程度地减少死锁和应用程序中所需的后续错误处理。

死锁是事务型数据库中的经典问题，但它并不危险，除非它非常频繁，以至于您根本无法运行某些事务。通常，您必须编写应用程序，以便==事务因死锁而回滚时==，总是准备==重新执行事务==。

InnoDB 使用自动的行级锁。即使在事务只插入或删除单行的情况下，也可能会出现死锁。这是因为这些操作并不是真正的原子操作；它们自动对插入或删除的行（可能是多条）的索引记录加锁。

您可以使用以下技巧来==处理死锁并减少其发生的可能性==：

- 在任何时候，执行 [`SHOW ENGINE INNODB STATUS`](https://dev.mysql.com/doc/refman/5.7/en/show-engine.html) 命令来确定最新死锁的原因。这可以帮助您调整应用程序以避免死锁。 

- 如果频繁的死锁警告产生了影响，可以通过启用 [`innodb_print_all_deadlocks`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_print_all_deadlocks) 选项来收集更多的调试信息。关于每次死锁的信息，不仅仅是最新的死锁，都会记录在 MySQL [error log](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_error_log) 中。完成调试后，请禁用此选项。

- 如果事务因死锁而失败，则随时重新执行事务准备====。

- 为了使事务不易发生冲突，请==使事务尽可能的小且执行时间尽可能的短==。

- 在完成一系列相关更改后立即提交事务，以减少冲突。特别是，不要让一个拥有未提交的事务的交互式 mysql 会话长时间处于打开状态。

- 如果使用锁定读（[`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 或 `SELECT ... LOCK IN SHARE MODE`），请尝试较低的隔离级别，例如 READ COMMITTED。

- 修改事务中的多个表或同一表中的不同行时，每次都要以==一样的顺序==执行这些操作。这样，事务会形成定义明确的队列，且不会死锁。例如，将数据库操作组织到应用程序中的函数中，或者调用存储过程，而不是在不同的地方编码多个类似的 INSERT、UPDATE 和 DELETE 语句序列。

- 向表中添加精心选择的索引。这样，您的查询能够扫描更少的索引记录，从而设置更少的锁。使用 [`EXPLAIN SELECT`](https://dev.mysql.com/doc/refman/5.7/en/explain.html) 来确定 MySQL 服务器认为哪个索引最适合您的查询。

- 使用更少的锁。如果允许 SELECT 从旧快照中返回数据，则不要添加 `FOR UPDATE`或 `LOCK IN SHARE MODE` 子句。这时使用 READ COMMITTED 隔离级别很好，因为同一事务中的每个一致性读都从自己的新快照中读取。

- 如果没有其他帮助，可以使用表级锁序列化事务。对于事务表（例如 InnoDB 表），正确使用 [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) 的方法是：使用 `SET autocommit = 0` 开始事务，而不是  [`START TRANSACTION`](https://dev.mysql.com/doc/refman/5.7/en/commit.html)，紧接着去 [`LOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) ，并且在显式提交事务之前不调用 [`UNLOCK TABLES`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html) 。例如，如果你需要写表 t1 和读表 t2，你可以这样做：

  ```sql
  SET autocommit=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  ... do something with tables t1 and t2 here ...
  COMMIT;
  UNLOCK TABLES;
  ```

  表级锁可防止对表的并发更新，从而避免死锁，但代价是使繁忙系统的响应速度变慢。

- ==序列化事务==的另一种方法是创建一个仅==包含一行的辅助“信号量”表==。让每个事务在访问其他表之前先更新该行。这样，所有事务都以串行方式进行。注意，在这种情况下，InnoDB 即时死锁检测算法也适用，因为序列化锁是行级锁。==对于 MySQL 表级锁，必须使用超时方法来解决死锁。==
