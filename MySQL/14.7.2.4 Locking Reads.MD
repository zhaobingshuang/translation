#### 14.7.2.4 Locking Reads

先查询数据，然后在同一事务中插入或更新相关的数据，常规的 SELECT 语句不能提供足够的保护。其他事务可以更新或删除你刚才查询出的数据行。InnoDB 支持两种类型的锁定读，这提供了额外的安全性：

- [`SELECT ... LOCK IN SHARE MODE`](https://dev.mysql.com/doc/refman/5.7/en/select.html)

  在读取的行上加共享锁。其他会话可以读取这些行，但不能修改它们，直到你的事务提交。如果某些行被另一个事务修改了，但还没提交，则查询将等待该事务结束，然后使用最新的值。

- [`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html)

  对于搜索中遇到的索引记录，将会锁定这些行以及任何相关的索引项，就像对这些行执行 UPDATE 语句一样。其他事务的以下操作会被阻塞：更新这些行，执行`SELECT ... LOCK IN SHARE MODE`，某些事务隔离级别下的读。一致性读会忽略 read view 中的任何锁。（记录的旧版本不会被锁定；通过在记录的内存副本上应用 [undo logs](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log) ，可以重构它们。）

TODO

提交或回滚事务时，将释放由 `LOCK IN SHARE MODE` 和 `FOR UPDATE` 查询加的所有锁。

> **Note**
>
> 仅当禁用了自动提交（使用 START TRANSACTION 开始事务或将 [`autocommit`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit) 设置为0）时，才可以进行锁定读。

==除非在子查询中也使用了锁定读子句，否则外部语句中的锁定读子句不会锁定嵌套子查询中表的行。==例如，以下语句不会锁定表 t2 中的行。

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE;
```

要锁定表 t2 中的行，请向子查询添加一个锁定读子句：

```sql
SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE;
```

##### Locking Read Examples

假设你要在表 `child` 中插入新行，并确保该子行在表 `parent` 中具有父行。你的应用程序代码可以确保整个操作序列的引用完整性。 

首先，使用一致性读查询表 `parent`，并确定父行是存在的。你可以安全地将子行插入表 `child` 吗？不可以，因为其他会话可能会在你执行 SELECT 到 INSERT 中间的间隔删除父行，而你却不知道这个操作。

为了避免这个潜在的问题，应该使用 `SELECT ... LOCK IN SHARE MODE`：

```sql
SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
```

在 LOCK IN SHARE MODE 查询返回父行 'Jones' 后，你可以安全地将子记录添加到 `child`表中并提交事务。任何试图获取 `parent` 表的对应行的排他锁的事务都将等待，直到你完成操作，即直到所有表中的数据处于一致的状态。



另一个例子，考虑表 CHILD_CODES 中有一个整数计数器字段，该字段用于为添加到表 CHILD 的每行分配唯一标识符。==不要使用一致性读或共享模式读来读取计数器的当前值==，因为两个数据库用户可能会看到该计数器的相同值，并且如果两个事务尝试用相同的标识符向 CHILD 插入数据，则会发生 duplicate-key 错误。

在这里，LOCK IN SHARE MODE 不是一个好的解决方案，因为如果两个用户同时读取计数器，则其中==至少有一个在尝试更新计数器时会陷入死锁状态==。

要实现计数器的读取和递增，请先使用 FOR UPDATE 对计数器执行锁定读，然后再递增计数器。例如：

```sql
SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
```

[`SELECT ... FOR UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/select.html) 读取最新的可用数据，并在读取的每一行上加排他锁。因此，它加了与 [`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 一样的锁。

前面的描述只是 SELECT ... FOR UPDATE 工作方式的一个示例。==在 MySQL 中，生成唯一标识符的特定任务实际上只需要对表进行一次访问就可以完成==：

```sql
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
```

这个 SELECT 语句仅检索标识符信息（特定于当前连接）。它不访问任何表。