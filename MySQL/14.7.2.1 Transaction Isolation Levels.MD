# 14.7.2.1 Transaction Isolation Levels

事务隔离是数据库处理工作的基础之一。隔离是缩写 [ACID](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_acid)中的 I；隔离级别是一种设置，用于在多个事务同时进行更改和查询时调整性能与可靠性、一致性以及结果可再现性之间的平衡。

InnoDB 提供了SQL：1992 标准描述的所有四个事务隔离级别：[`READ UNCOMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted)、 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)、 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read) 和 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)。 InnoDB 的默认隔离级别是 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)。

用户可以使用 [`SET TRANSACTION`](https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html) 语句更改单个会话或所有后续连接的隔离级别。要为所有连接设置服务器的默认隔离级别，请在命令行或选项文件中使用 [`--transaction-isolation`](https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_transaction-isolation)选项。有关隔离级别和级别设置语法的详细信息，请参见 [Section 13.3.6, “SET TRANSACTION Statement”](https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html)。

InnoDB 使用不同的锁策略支持此处描述的每个事务隔离级别。可以在默认的 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read) 级别上获取高度的一致性，以实现对重要数据（ACID遵从性很重要）的操作。或者，可以使用 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed) 或 [`READ UNCOMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-uncommitted) 来放宽一致性的要求，比如在批量报告的情况下，精确的一致性和可重复的结果不如最小化锁的开销那么重要。[`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable) 强制执行比 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read) 更严格的规则，并且主要用于特殊情况下，例如 [XA](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_xa) 事务以及对并发和死锁问题进行故障排除。

下面的列表描述了 MySQL 如何支持不同的事务级别。这个列表从最常用的级别到最少使用的。

- REPEATABLE READ

  这是 InnoDB 的默认隔离级别。同一事务中的一致读取将读取由第一次读取建立的快照。这意味着，如果在同一事务中执行多个普通（非锁定）[`SELECT`](https://dev.mysql.com/doc/refman/5.7/en/select.html)语句，则这些 SELECT 语句彼此之间也是一致的。请参见 [Section 14.7.2.3, “Consistent Nonlocking Reads”](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)。

  对于锁定读（[`SELECT`](https://dev.mysql.com/doc/refman/5.7/en/select.html) ...`FOR UPDATE` or `LOCK IN SHARE MODE`）、[`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 和 [`DELETE`](https://dev.mysql.com/doc/refman/5.7/en/delete.html) 语句，锁取决于该语句是使用具有唯一搜索条件的唯一索引还是范围类型搜索条件。

  - 对于具有唯一搜索条件的唯一索引，InnoDB 仅锁定找到的索引记录，而不锁定之前的间隙 。
  - 对于其他搜索条件，InnoDB 使用 [gap locks](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock) 或 [next-key locks](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock) 来锁定扫描过的索引范围，以阻止其他会话插入该范围覆盖的间隙。有关 gap locks 和 next-key locks 的信息，请参见 [Section 14.7.1, “InnoDB Locking”](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)。

- READ COMMITTED

  即使在同一事务中，每个一致读都将设置并读取其自己的==新快照==。有关一致读的信息，请参见[Section 14.7.2.3, “Consistent Nonlocking Reads”](https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html)。

  对于锁定读（[`SELECT`](https://dev.mysql.com/doc/refman/5.7/en/select.html) ...`FOR UPDATE` or `LOCK IN SHARE MODE`）、[`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 和 [`DELETE`](https://dev.mysql.com/doc/refman/5.7/en/delete.html) 语句，InnoDB ==只会锁定索引记录，而不锁定它们之前的间隙==，因此允许在被锁定记录旁边自由插入新记录。间隙锁只被用于外键约束检查和重复键检查。

  由于间隙锁被禁用了，因此==可能会产生幻读问题==，因为其他会话可以在间隙中插入新行。有关幻读的信息，请参见 [Section 14.7.4, “Phantom Rows”](https://dev.mysql.com/doc/refman/5.7/en/innodb-next-key-locking.html)。

  READ COMMITTED 只支持基于行的二进制日志记录。如果将 READ COMMITTED 与 binlog_format = MIXED 一起使用，则服务器将自动使用基于行的日志记录。

  使用 READ COMMITTED 还有其他的效果：

  - 对于 [`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 或 [`DELETE`](https://dev.mysql.com/doc/refman/5.7/en/delete.html) 语句，InnoDB 只持有它更新或删除的记录的锁。MySQL 判断玩 WHERE 条件后，将释放那些不匹配行上的锁。这大大降低了死锁的概率，但死锁仍然可能发生。
  - 对于 [`UPDATE`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 语句，如果某行已被锁定，InnoDB 会执行“半一致”读，返回最新提交的版本给 MySQL，这样 MySQL 就可以判断该行是否与 UPDATE 的 WHERE 条件匹配。如果匹配（该行需要被更新），MySQL 将再次读取该行，这一次 InnoDB 要么直接对该行加锁，要么等待对其进行锁定。

  考虑从该表开始的以下示例：

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
  COMMIT;
  ```

  在这种情况下，==表没有索引，所以搜索和索引扫描使用隐藏的聚集索引来锁定记录==（[Section 14.6.2.1, “Clustered and Secondary Indexes”](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)），而不是索引列。

  假设一个会话执行一下 UPDATE：

  ```sql
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 5 WHERE b = 3;
  ```

  第二个会话在第一个会话之后执行以下 UPDATE：

  ```sql
  # Session B
  UPDATE t SET b = 4 WHERE b = 2;
  ```

  当 InnoDB 执行每个 UPDATE 时，它首先为其读取到的每一行加排他锁，然后判断是否要修改它。如果 InnoDB 不需要修改该行，将释放该行锁。否则，InnoDB 将保留锁直到事务结束。这会影响事务处理，如下所示。

  当使用默认的 REPEATABLE READ 隔离级别时，第一个 UPDATE 在其读取的每一行上加一个 x 锁，并且不释放其中的任何一个：

  ```
  x-lock(1,2); retain x-lock
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); retain x-lock
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); retain x-lock
  ```

  第二个 UPDATE 在尝试获取任何锁时立即阻塞（因为第一个 UPDATE  已持有所有行的锁），并且直到第一个 UPDATE 提交或回滚后才继续进行：

  ```
  x-lock(1,2); block and wait for first UPDATE to commit or roll back
  ```

  如果使用的是 READ COMMITTED，则第一个 UPDATE 在其读取的每一行上加一个 x 锁，并释放不需要修改的行的 x 锁：

  ```
  x-lock(1,2); unlock(1,2)
  x-lock(2,3); update(2,3) to (2,5); retain x-lock
  x-lock(3,2); unlock(3,2)
  x-lock(4,3); update(4,3) to (4,5); retain x-lock
  x-lock(5,2); unlock(5,2)
  ```

  对于第二个 UPDATE，InnoDB 执行“半一致”读，将它读取的每一行最新提交的版本返回给 MySQL，这样 MySQL 就可以判断该行是否与 UPDATE 的 WHERE 条件匹配：

  ```
  x-lock(1,2); update(1,2) to (1,4); retain x-lock
  x-lock(2,3); unlock(2,3)
  x-lock(3,2); update(3,2) to (3,4); retain x-lock
  x-lock(4,3); unlock(4,3)
  x-lock(5,2); update(5,2) to (5,4); retain x-lock
  ```

  但是，如果 WHERE 条件包含有索引的列，并且 InnoDB 使用这些索引，则在获取和保留记录锁时只会考虑索引列。在下面的示例中，第一个 UPDATE 在 b = 2 的每一行上获取并保留一个 x 锁。第二个 UPDATE 在尝试获取同一记录上的 x 锁时会阻塞，因为它也使用了 b 列的索引。

  ```sql
  CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
  INSERT INTO t VALUES (1,2,3),(2,2,4);
  COMMIT;
  
  # Session A
  START TRANSACTION;
  UPDATE t SET b = 3 WHERE b = 2 AND c = 3;
  
  # Session B
  UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
  ```

  使用 READ COMMITTED 隔离级别的效果与启用已弃用的 innodb_locks_unsafe_for_binlog 配置选项相同，但以下情况除外：

  - 启用 innodb_locks_unsafe_for_binlog 是全局设置，并且会影响所有会话，而隔离级别可以针对所有会话全局设置，也可以针对每个会话单独设置。 
  - innodb_locks_unsafe_for_binlog 只能在服务器启动时设置，而隔离级别可以在启动时设置或在运行时更改。

- READ UNCOMMITTED

  SELECT 语句以非锁定的方式执行，但是可能会使用行的早期版本。因此，使用此隔离级别，读是不一致。这也称为==脏读==。否则，此隔离级别的工作方式类似于 READ COMMITTED。

- SERIALIZABLE

  此级别类似于 REPEATABLE READ，但如果禁用了 [`autocommit`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit)，InnoDB 会隐式精所有普通的 SELECT 语句转换为 SELECT ... LOCK IN SHARE MODE。

此级别类似于REPEATABLE READ，但如果禁用了自动提交，则InnoDB会将所有普通的SELECT语句隐式转换为SELECT ... LOCK IN SHARE MODE。如果启用了 [`autocommit`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit)，则 SELECT 是它自己的事务。

如果启用了自动提交，则SELECT是它自己的事务。因此，我们知道它是只读的，如果作为一致的非锁定的读执行，它可以被串行化。（其他事务语句修改了要查询的行时，如要强制普通 SELECT 阻塞，要禁用autocommit。）