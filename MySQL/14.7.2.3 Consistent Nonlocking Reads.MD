# 14.7.2.3 Consistent Nonlocking Reads

一致性读意味着 InnoDB 使用多版本技术向查询提供数据库在某个时间点的快照。该查询能看到在该时间点之前提交的事务所做的更改，而看不到该时间点以后或未提交的事务所做的更改。该规则的例外是：查询可以看到同一事务中前面的语句所做的更改。这个例外会导致一下的情况：如果更新了表中的某些行，SELECT 能看到被更新行的最新版本，但也可能会看到其他行的旧版本。这种异常意味着你可能会看到该表处于数据库中从未存在过的状态。

如果事务隔离级别是 [`REPEATABLE READ`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read)（默认值），同一事务中的所有一致读将读取该事务中第一个此类读所建立的快照。你可以通过提交当前事务并执行新查询来获取更新的快照。

==使用 [`READ COMMITTED`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)，事务中的每个一致性读都将设置并读取自己的新鲜快照。==

一致读是 InnoDB 在READ COMMITTED和REPEATABLE READ隔离级别中处理SELECT语句的默认模式。一致读不会在它访问的表上加任何锁，因此在对表执行一致性读的同时，其他会话可以自由地修改这些表。

假设你以默认的REPEATABLE READ隔离级别运行。当您执行一致性读（普通的 SELECT 语句）时，InnoDB 会给你的事务一个时间点，它与你的查询能看到的数据库内容相关。如果另一个事务删除了一行且在时间点被分配后提交，则不会将该行视为已删除。插入和更新的处理方式类似。

> **Note**
>
> ==数据库状态的快照==适用于事务中的 SELECT 语句，==不一定适用于 DML 语句==。如果你插入或修改某些行，然后提交该事务，则来自另一个并发的 REPEATABLE READ 事务的 DELETE 或 UPDATE 语句可能会影响这些刚刚提交的行，即使会话不能查询到它们。==如果某个事务更新或删除了由另一个事务提交的行，则这些更改将对当前事务可见==。例如，你可能会遇到以下情况：
>
> ```sql
> SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';
> -- Returns 0: no rows match.
> DELETE FROM t1 WHERE c1 = 'xyz';
> -- Deletes several rows recently committed by other transaction.
> 
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
> -- Returns 0: no rows match.
> UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
> -- Affects 10 rows: another txn just committed 10 rows with 'abc' values.
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
> -- Returns 10: this txn can now see the rows it just updated.
> ```

可以通过提交事务，然后执行另一个 SELECT 或 [`START TRANSACTION WITH CONSISTENT SNAPSHOT`](https://dev.mysql.com/doc/refman/5.7/en/commit.html) 来后移您的时间点。

这称为多版本并发控制。

在下面的例子中，只有当 B 提交了插入，并且 A 也提交了，会话 A 才会看到 B 插入的行，因为时间点被后移到 B 的提交之后。

```sql
             Session A              Session B

           SET autocommit=0;      SET autocommit=0;
time
|          SELECT * FROM t;
|          empty set
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           empty set
                                  COMMIT;

           SELECT * FROM t;
           empty set

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

如果要查看数据库的最新状态，请使用 READ COMMITTED 隔离级别或锁定读：

```sql
SELECT * FROM t LOCK IN SHARE MODE;
```

使用 READ COMMITTED 隔离级别，事务中的每个一致性读都会设置并读取其自己的新快照。使用 LOCK IN SHARE MODE 时，会发生锁定读：SELECT 操作会被阻塞，直到包含最新行的事务结束（see [Section 14.7.2.4, “Locking Reads”](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html)）。 

==一致性读不适用于某些 DDL 语句==：

- 一致的读取对 [`DROP TABLE`](https://dev.mysql.com/doc/refman/5.7/en/drop-table.html) 不起作用，因为 MySQL 无法使用已删除的表，并且 InnoDB 会破坏该表。 
- 一致性读取不能用于 [`ALTER TABLE`](https://dev.mysql.com/doc/refman/5.7/en/alter-table.html)  操作，该操作会创建原始表的临时副本并在构建完临时副本后删除原始表。当在事务中重新执行一致性读时，新表中的行是不可见的，因为在创建事务的快照时这些行还不存在。在这种情况下，事务返回错误：[`ER_TABLE_DEF_CHANGED`](https://dev.mysql.com/doc/mysql-errors/5.7/en/server-error-reference.html#error_er_table_def_changed), “Table definition has changed, please retry transaction”。

对于未指定 FOR UPDATE 或 LOCK IN SHARE MODE 的 [`INSERT INTO ... SELECT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html)、 [`UPDATE ... (SELECT)`](https://dev.mysql.com/doc/refman/5.7/en/update.html) 和[`CREATE TABLE ... SELECT`](https://dev.mysql.com/doc/refman/5.7/en/create-table.html)  之类的 select in子句：

- 默认情况下，InnoDB 会使用==更强的锁==，并且 ==SELECT 部分的行为类似于 READ COMMITTED==，每个一致性读（即使在同一事务中）也会设置并读取自己的新快照。 
- 想在这种情况下执行非锁定读，请启用 [`innodb_locks_unsafe_for_binlog`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog) 选项，并将事务的隔离级别设置为 READ UNCOMMITTED、READ COMMITTED 或 REPEATABLE READ，以避免在 select 的表中的行上加锁。