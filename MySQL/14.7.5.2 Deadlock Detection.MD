#### 14.7.5.2 Deadlock Detection

启用死锁检测（默认）后，InnoDB 自动检测事务死锁并回滚一个或多个事务以打破死锁。 InnoDB 尝试回滚小事务，其中事务的大小由插入、更新或删除的行数决定。

如果 innodb_table_locks = 1（默认值）且 autocommit = 0，则 InnoDB 能感知表锁，并且它之上的MySQL 层也能感知行级锁。否则，InnoDB 无法检测到涉及 MySQL 层 LOCK TABLES 语句加的表锁或 InnoDB 以外的存储引擎加的锁造成的死锁。通过设置 [`innodb_lock_wait_timeout`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_lock_wait_timeout) 系统变量的值来解决这些情况。

如果 InnoDB Monitor 输出的 LATEST DETECTED DEADLOCK 部分包含这样一条消息：“TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,”，这表明等待列表中的事务数已达到 200 的限制。超过 200 个事务的等待列表将被视为死锁，试图检查等待列表的事务将被回滚。如果正在锁定的线程必须查看等待列表上的事务拥有的1,000,000 个以上的锁，也可能发生相同的错误。

##### Disabling Deadlock Detection

在高并发系统上，当多个线程等待相同的锁时，死锁检测会导致速度变慢。有时，当发生死锁时，禁用死锁检测并依靠 innodb_lock_wait_timeout 设置进行事务回滚可能会更有效。可以使用 [`innodb_deadlock_detect`](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_deadlock_detect) 配置选项禁用死锁检测。

