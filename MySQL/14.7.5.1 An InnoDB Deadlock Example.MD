#### 14.7.5.1 An InnoDB Deadlock Example

下面的例子说明了当锁请求如何导致死锁发生的。该示例涉及两个客户端，A 和 B。

首先，客户端 A 创建一个包含一行的表，然后开始事务。在事务中，A 通过在共享模式下 SELECT 该行来获得该行的 S 锁：

```sql
mysql> CREATE TABLE t (i INT) ENGINE = InnoDB;
Query OK, 0 rows affected (1.07 sec)

mysql> INSERT INTO t (i) VALUES(1);
Query OK, 1 row affected (0.09 sec)

mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;
+------+
| i    |
+------+
|    1 |
+------+
```

接下来，客户端 B 开始事务并尝试从表中删除该行：

```sql
mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql> DELETE FROM t WHERE i = 1;
```

删除操作需要 X 锁。这个锁不能被授予，因为它与客户端 A 持有的 S 锁不兼容，因此，这个针对该行的锁请求会入队且客户端 B 会被阻塞。

最后，客户端 A 也尝试从表中删除该行：

```sql
mysql> DELETE FROM t WHERE i = 1;
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
```

此处会发生死锁，因为客户端 A 需要 X 锁才能删除该行。但是，这个锁请求不能被授予，因为客户端 B 已经有一个 X 锁的请求，并且正在等待客户端 A 释放它的 S 锁。由于 B 先请求了 X 锁，因此 A 持有的 S 锁也不能升级为 X 锁。结果就是，InnoDB 为其中一个客户端生成错误并释放其锁。客户端返回此错误：

```shell
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
```

此时，另一个客户端的锁请求可以被授予，并从表中删除该行。